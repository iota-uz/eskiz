/*
СМС шлюз от Eskiz.uz

Отправляйте СМС по всему миру, в любом количестве!  В тестовом статусе для отправки тестовых смс сообщений, Вы можете использовать только нижеуказанные тексты:  - Это тест от Eskiz      - Bu Eskiz dan test      - This is test from Eskiz

API version: 1.0.0
Contact: danil@iota.uz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package eskizapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type DefaultApi interface {

	/*
		ExportMessages Экспортировать в формате CSV

		Экспортировать в формате CSV

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiExportMessagesRequest
	*/
	ExportMessages(ctx context.Context) DefaultApiExportMessagesRequest

	// ExportMessagesExecute executes the request
	//  @return *os.File
	ExportMessagesExecute(r DefaultApiExportMessagesRequest) (*os.File, *http.Response, error)

	/*
		GetDispatchStatus Статус рассылки

		Получить статус рассылки

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetDispatchStatusRequest
	*/
	GetDispatchStatus(ctx context.Context) DefaultApiGetDispatchStatusRequest

	// GetDispatchStatusExecute executes the request
	//  @return DispatchStatusResponse
	GetDispatchStatusExecute(r DefaultApiGetDispatchStatusRequest) (*DispatchStatusResponse, *http.Response, error)

	/*
		GetNicknames Получить список ник

		Получить список ник

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetNicknamesRequest
	*/
	GetNicknames(ctx context.Context) DefaultApiGetNicknamesRequest

	// GetNicknamesExecute executes the request
	//  @return []string
	GetNicknamesExecute(r DefaultApiGetNicknamesRequest) ([]string, *http.Response, error)

	/*
		GetSmsLogs Системные логи

		Системные логи

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID СМС
		@return DefaultApiGetSmsLogsRequest
	*/
	GetSmsLogs(ctx context.Context, id string) DefaultApiGetSmsLogsRequest

	// GetSmsLogsExecute executes the request
	//  @return SmsLogsResponse
	GetSmsLogsExecute(r DefaultApiGetSmsLogsRequest) (*SmsLogsResponse, *http.Response, error)

	/*
			GetSmsStatusById Получить статус по ID

			Если :id INT - это ID SMS на платформе Eskiz

		Если :id UUID - это id, полученный в результате вызова API send, send-batch и send-global, или столбец request_id в результатах остальных API.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param id
			@return DefaultApiGetSmsStatusByIdRequest
	*/
	GetSmsStatusById(ctx context.Context, id string) DefaultApiGetSmsStatusByIdRequest

	// GetSmsStatusByIdExecute executes the request
	//  @return SmsStatusResponse
	GetSmsStatusByIdExecute(r DefaultApiGetSmsStatusByIdRequest) (*SmsStatusResponse, *http.Response, error)

	/*
		GetTotalByDispatch Расходы по рассылке

		Расходы по рассылке

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetTotalByDispatchRequest
	*/
	GetTotalByDispatch(ctx context.Context) DefaultApiGetTotalByDispatchRequest

	// GetTotalByDispatchExecute executes the request
	//  @return UserTotalsResponse
	GetTotalByDispatchExecute(r DefaultApiGetTotalByDispatchRequest) (*UserTotalsResponse, *http.Response, error)

	/*
			GetTotalByMonth Итого по месяцам

			**ad_parts** - Количество рекламных СМС
		**ad_spent** - Расходы на рекламные СМС

		**parts** - Количество сервисных СМС
		**spent** - Расходы на сервисные СМС

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiGetTotalByMonthRequest
	*/
	GetTotalByMonth(ctx context.Context) DefaultApiGetTotalByMonthRequest

	// GetTotalByMonthExecute executes the request
	//  @return TotalByMonthResponse
	GetTotalByMonthExecute(r DefaultApiGetTotalByMonthRequest) (*TotalByMonthResponse, *http.Response, error)

	/*
		GetTotalByRange Расходы по датам

		Расходы по датам

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetTotalByRangeRequest
	*/
	GetTotalByRange(ctx context.Context) DefaultApiGetTotalByRangeRequest

	// GetTotalByRangeExecute executes the request
	//  @return UserTotalsResponse
	GetTotalByRangeExecute(r DefaultApiGetTotalByRangeRequest) (*UserTotalsResponse, *http.Response, error)

	/*
			GetTotalBySmsc Итого по компаниям

			**smsc_id** - ID компании

		| smsc_id | Компания |
		| --- | --- |
		| 1 | Mobiuz |
		| 2 | Beeline |
		| 3 | Ucell |
		| 4 | Humans |
		| 5 | Uzmobile GSM |
		| 6 | Uzmobile CDMA |
		| 7 | Perfectum |
		| 8 | Global |

		**ad_parts** - Количество рекламных СМС
		**ad_spent** - Расходы на рекламные СМС

		**parts** - Количество сервисных СМС
		**spent** - Расходы на сервисные СМС

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiGetTotalBySmscRequest
	*/
	GetTotalBySmsc(ctx context.Context) DefaultApiGetTotalBySmscRequest

	// GetTotalBySmscExecute executes the request
	//  @return TotalBySmscResponse
	GetTotalBySmscExecute(r DefaultApiGetTotalBySmscRequest) (*TotalBySmscResponse, *http.Response, error)

	/*
		GetUserInfo Данные ползователья

		Возвращает все данные о пользователе

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetUserInfoRequest
	*/
	GetUserInfo(ctx context.Context) DefaultApiGetUserInfoRequest

	// GetUserInfoExecute executes the request
	//  @return UserInfoResponse
	GetUserInfoExecute(r DefaultApiGetUserInfoRequest) (*UserInfoResponse, *http.Response, error)

	/*
		GetUserLimit Получить баланс

		Получить баланс

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetUserLimitRequest
	*/
	GetUserLimit(ctx context.Context) DefaultApiGetUserLimitRequest

	// GetUserLimitExecute executes the request
	//  @return UserLimitResponse
	GetUserLimitExecute(r DefaultApiGetUserLimitRequest) (*UserLimitResponse, *http.Response, error)

	/*
			GetUserMessages Детализация

			**id** - Идентификатор пользователя
		**country_id** - Идентификатор страны, куда отправлено SMS (null - Узбекистан)
		**smsc_id** - Идентификатор компании, отправившей SMS
		**dispatch_id** - Идентификатор рассылки
		**user_sms_id** - Идентификатор SMS, который отправил пользователь
		**request_id** - Идентификатор запроса, по которому было отправлено SMS
		**price** - Цена за каждую часть SMS (полная стоимость SMS вычисляется как price \* parts_count)
		**is_ad** - Рекламное SMS
		**nick** - Никнейм
		**to** - Номер телефона, на который отправлено SMS
		**message** - Текст SMS
		**encoding** - Способ кодирования SMS (0 - GSM 0338, 1 - ASCII, 8 - UCS2)
		**parts_count** - Количество частей SMS (зависит от типа кодировки)
		**parts**: - Информация о частях SMS

		- **\[MSG_ID\]**: Идентификатор SMS, полученный от компании

		    - **part_index** - Порядковый номер каждой части SMS

		    - **accepted** - true или false

		    - **accept_time** - Время отправки SMS

		    - **accept_status** - Состояние SMS, полученной от компании (значение SubmitSMResp.CommandStatus)

		    - **dlr_state** - Статус доставленного SMS

		    - **dlr_time** - Время доставки SMS


		**status** - Общее состояние SMS
		**smsc_data** - Изменение состояния для каждой части
		**sent_at** - Время, когда система Eskiz.uz приняла SMS
		**submit_sm_resp_at** - Время отправки последней части SMS компании
		**delivery_sm_at** - Время доставки последней части SMS пользователю
		**created_at** - Дата создания записи
		**updated_at** - Дата последнего изменения записи

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiGetUserMessagesRequest
	*/
	GetUserMessages(ctx context.Context) DefaultApiGetUserMessagesRequest

	// GetUserMessagesExecute executes the request
	//  @return UserMessagesResponse
	GetUserMessagesExecute(r DefaultApiGetUserMessagesRequest) (*UserMessagesResponse, *http.Response, error)

	/*
		GetUserMessagesByDispatch Получить СМС по рассылке

		Получить все отправленные СМС по ID рассылке

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetUserMessagesByDispatchRequest
	*/
	GetUserMessagesByDispatch(ctx context.Context) DefaultApiGetUserMessagesByDispatchRequest

	// GetUserMessagesByDispatchExecute executes the request
	//  @return UserMessagesResponse
	GetUserMessagesByDispatchExecute(r DefaultApiGetUserMessagesByDispatchRequest) (*UserMessagesResponse, *http.Response, error)

	/*
			GetUserTemplates Получить список шаблонов

			Получить все шаблоны

		status:
		moderation => На модерации
		inproccess => В процессе
		service => Сервисный
		reklama => Рекламный
		rejected => Отказано

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiGetUserTemplatesRequest
	*/
	GetUserTemplates(ctx context.Context) DefaultApiGetUserTemplatesRequest

	// GetUserTemplatesExecute executes the request
	//  @return TemplatesListResponse
	GetUserTemplatesExecute(r DefaultApiGetUserTemplatesRequest) (*TemplatesListResponse, *http.Response, error)

	/*
		GetUserTotals Итог отправленных СМС

		Итого отправленных СМС

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiGetUserTotalsRequest
	*/
	GetUserTotals(ctx context.Context) DefaultApiGetUserTotalsRequest

	// GetUserTotalsExecute executes the request
	//  @return UserTotalsResponse
	GetUserTotalsExecute(r DefaultApiGetUserTotalsRequest) (*UserTotalsResponse, *http.Response, error)

	/*
		Login Получить токен

		Для авторизации используйте этот API, возвращает токен

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiLoginRequest
	*/
	Login(ctx context.Context) DefaultApiLoginRequest

	// LoginExecute executes the request
	//  @return LoginResponse
	LoginExecute(r DefaultApiLoginRequest) (*LoginResponse, *http.Response, error)

	/*
			NormalizeSms Нормализации SMS

			Этот API предоставляет информацию о наличии специальных символов в SMS-сообщении, а также о том, какими символами можно заменить специальные символы.

		Используя этот API, вы можете отправлять свои SMS дешевле.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiNormalizeSmsRequest
	*/
	NormalizeSms(ctx context.Context) DefaultApiNormalizeSmsRequest

	// NormalizeSmsExecute executes the request
	//  @return NormalizeSmsResponse
	NormalizeSmsExecute(r DefaultApiNormalizeSmsRequest) (*NormalizeSmsResponse, *http.Response, error)

	/*
		RefreshToken Обновить токен

		Обновляет текущий токен

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiRefreshTokenRequest
	*/
	RefreshToken(ctx context.Context) DefaultApiRefreshTokenRequest

	// RefreshTokenExecute executes the request
	//  @return RefreshTokenResponse
	RefreshTokenExecute(r DefaultApiRefreshTokenRequest) (*RefreshTokenResponse, *http.Response, error)

	/*
			SendSms Отправить СМС

			Для того, чтобы использовать никнейм, вам нужно поменять поле «FROM» на свои.

		**callback_url** - Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате:

		**{"request_id": "UUID", "message_id": "4385062", "user_sms_id": "vash_ID_zdes", "country": "UZ", "phone_number": "998991234567", "sms_count": "1", "status" : "DELIVRD", "status_date": "2021-04-02 00:39:36"}**

		`request_id` — это значение, возвращаемое в поле "id" в результате выполнения API запросов send, send-batch и send-global.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiSendSmsRequest
	*/
	SendSms(ctx context.Context) DefaultApiSendSmsRequest

	// SendSmsExecute executes the request
	//  @return SendSmsResponse
	SendSmsExecute(r DefaultApiSendSmsRequest) (*SendSmsResponse, *http.Response, error)

	/*
		SendSmsBatch Отправить СМС рассылка

		Отправить СМС рассылка

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiSendSmsBatchRequest
	*/
	SendSmsBatch(ctx context.Context) DefaultApiSendSmsBatchRequest

	// SendSmsBatchExecute executes the request
	//  @return SendSmsBatchResponse
	SendSmsBatchExecute(r DefaultApiSendSmsBatchRequest) (*SendSmsBatchResponse, *http.Response, error)

	/*
			SendSmsGlobal Отправить Международный СМС

			Используя этот API вы можете отправить СМС зарубежных стран мира.

		**callback_url** - Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате:

		**{"message_id": "4385062", "country": "US", "phone_number": "1234567891011", "sms_count": "1", "status" : "DELIVRD", "status_date": "2021-04-02 00:39:36"}**

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return DefaultApiSendSmsGlobalRequest
	*/
	SendSmsGlobal(ctx context.Context) DefaultApiSendSmsGlobalRequest

	// SendSmsGlobalExecute executes the request
	//  @return SendSmsResponse
	SendSmsGlobalExecute(r DefaultApiSendSmsGlobalRequest) (*SendSmsResponse, *http.Response, error)

	/*
		SendTemplate Отправить шаблон

		Получить шаблон по ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return DefaultApiSendTemplateRequest
	*/
	SendTemplate(ctx context.Context) DefaultApiSendTemplateRequest

	// SendTemplateExecute executes the request
	//  @return SendTemplateResponse
	SendTemplateExecute(r DefaultApiSendTemplateRequest) (*SendTemplateResponse, *http.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type DefaultApiExportMessagesRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	status     *string
	end        *string
	month      *string
	start      *string
	year       *string
}

// &#x60;all&#x60; или &#x60;delivered&#x60; или &#x60;rejected&#x60;
func (r DefaultApiExportMessagesRequest) Status(status string) DefaultApiExportMessagesRequest {
	r.status = &status
	return r
}

// YYYY-MM-DD HH:mm:ss
func (r DefaultApiExportMessagesRequest) End(end string) DefaultApiExportMessagesRequest {
	r.end = &end
	return r
}

// Месяц
func (r DefaultApiExportMessagesRequest) Month(month string) DefaultApiExportMessagesRequest {
	r.month = &month
	return r
}

// YYYY-MM-DD HH:mm:ss
func (r DefaultApiExportMessagesRequest) Start(start string) DefaultApiExportMessagesRequest {
	r.start = &start
	return r
}

// Год
func (r DefaultApiExportMessagesRequest) Year(year string) DefaultApiExportMessagesRequest {
	r.year = &year
	return r
}

func (r DefaultApiExportMessagesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ExportMessagesExecute(r)
}

/*
ExportMessages Экспортировать в формате CSV

Экспортировать в формате CSV

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiExportMessagesRequest
*/
func (a *DefaultApiService) ExportMessages(ctx context.Context) DefaultApiExportMessagesRequest {
	return DefaultApiExportMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *DefaultApiService) ExportMessagesExecute(r DefaultApiExportMessagesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ExportMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "end", r.end, "", "")
	}
	if r.month != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "month", r.month, "", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start", r.start, "", "")
	}
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "year", r.year, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetDispatchStatusRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	dispatchId *string
	userId     *string
}

// ID рассылки
func (r DefaultApiGetDispatchStatusRequest) DispatchId(dispatchId string) DefaultApiGetDispatchStatusRequest {
	r.dispatchId = &dispatchId
	return r
}

// ID пользователя
func (r DefaultApiGetDispatchStatusRequest) UserId(userId string) DefaultApiGetDispatchStatusRequest {
	r.userId = &userId
	return r
}

func (r DefaultApiGetDispatchStatusRequest) Execute() (*DispatchStatusResponse, *http.Response, error) {
	return r.ApiService.GetDispatchStatusExecute(r)
}

/*
GetDispatchStatus Статус рассылки

Получить статус рассылки

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetDispatchStatusRequest
*/
func (a *DefaultApiService) GetDispatchStatus(ctx context.Context) DefaultApiGetDispatchStatusRequest {
	return DefaultApiGetDispatchStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DispatchStatusResponse
func (a *DefaultApiService) GetDispatchStatusExecute(r DefaultApiGetDispatchStatusRequest) (*DispatchStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DispatchStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetDispatchStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/get-dispatch-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.dispatchId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "dispatch_id", r.dispatchId, "", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "user_id", r.userId, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetNicknamesRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiGetNicknamesRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetNicknamesExecute(r)
}

/*
GetNicknames Получить список ник

Получить список ник

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetNicknamesRequest
*/
func (a *DefaultApiService) GetNicknames(ctx context.Context) DefaultApiGetNicknamesRequest {
	return DefaultApiGetNicknamesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []string
func (a *DefaultApiService) GetNicknamesExecute(r DefaultApiGetNicknamesRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetNicknames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/nick/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetSmsLogsRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	id         string
}

func (r DefaultApiGetSmsLogsRequest) Execute() (*SmsLogsResponse, *http.Response, error) {
	return r.ApiService.GetSmsLogsExecute(r)
}

/*
GetSmsLogs Системные логи

Системные логи

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID СМС
	@return DefaultApiGetSmsLogsRequest
*/
func (a *DefaultApiService) GetSmsLogs(ctx context.Context, id string) DefaultApiGetSmsLogsRequest {
	return DefaultApiGetSmsLogsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SmsLogsResponse
func (a *DefaultApiService) GetSmsLogsExecute(r DefaultApiGetSmsLogsRequest) (*SmsLogsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsLogsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmsLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/logs/sms/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetSmsStatusByIdRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	id         string
}

func (r DefaultApiGetSmsStatusByIdRequest) Execute() (*SmsStatusResponse, *http.Response, error) {
	return r.ApiService.GetSmsStatusByIdExecute(r)
}

/*
GetSmsStatusById Получить статус по ID

Если :id INT - это ID SMS на платформе Eskiz

Если :id UUID - это id, полученный в результате вызова API send, send-batch и send-global, или столбец request_id в результатах остальных API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id
	@return DefaultApiGetSmsStatusByIdRequest
*/
func (a *DefaultApiService) GetSmsStatusById(ctx context.Context, id string) DefaultApiGetSmsStatusByIdRequest {
	return DefaultApiGetSmsStatusByIdRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return SmsStatusResponse
func (a *DefaultApiService) GetSmsStatusByIdExecute(r DefaultApiGetSmsStatusByIdRequest) (*SmsStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SmsStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetSmsStatusById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/status_by_id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetTotalByDispatchRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	status     *string
	dispatchId *string
	isAd       *string
}

// [пустой] - все \&quot;delivered\&quot; - только частично и полностью доставленное \&quot;rejected\&quot; - только не доставленное
func (r DefaultApiGetTotalByDispatchRequest) Status(status string) DefaultApiGetTotalByDispatchRequest {
	r.status = &status
	return r
}

// ID рассылки
func (r DefaultApiGetTotalByDispatchRequest) DispatchId(dispatchId string) DefaultApiGetTotalByDispatchRequest {
	r.dispatchId = &dispatchId
	return r
}

// [пустой] - все 1 - только рекламное 0 - только сервисное
func (r DefaultApiGetTotalByDispatchRequest) IsAd(isAd string) DefaultApiGetTotalByDispatchRequest {
	r.isAd = &isAd
	return r
}

func (r DefaultApiGetTotalByDispatchRequest) Execute() (*UserTotalsResponse, *http.Response, error) {
	return r.ApiService.GetTotalByDispatchExecute(r)
}

/*
GetTotalByDispatch Расходы по рассылке

Расходы по рассылке

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetTotalByDispatchRequest
*/
func (a *DefaultApiService) GetTotalByDispatch(ctx context.Context) DefaultApiGetTotalByDispatchRequest {
	return DefaultApiGetTotalByDispatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserTotalsResponse
func (a *DefaultApiService) GetTotalByDispatchExecute(r DefaultApiGetTotalByDispatchRequest) (*UserTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTotalByDispatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/report/total-by-dispatch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.dispatchId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "dispatch_id", r.dispatchId, "", "")
	}
	if r.isAd != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_ad", r.isAd, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetTotalByMonthRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	year       *string
}

// Год
func (r DefaultApiGetTotalByMonthRequest) Year(year string) DefaultApiGetTotalByMonthRequest {
	r.year = &year
	return r
}

func (r DefaultApiGetTotalByMonthRequest) Execute() (*TotalByMonthResponse, *http.Response, error) {
	return r.ApiService.GetTotalByMonthExecute(r)
}

/*
GetTotalByMonth Итого по месяцам

**ad_parts** - Количество рекламных СМС
**ad_spent** - Расходы на рекламные СМС

**parts** - Количество сервисных СМС
**spent** - Расходы на сервисные СМС

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetTotalByMonthRequest
*/
func (a *DefaultApiService) GetTotalByMonth(ctx context.Context) DefaultApiGetTotalByMonthRequest {
	return DefaultApiGetTotalByMonthRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TotalByMonthResponse
func (a *DefaultApiService) GetTotalByMonthExecute(r DefaultApiGetTotalByMonthRequest) (*TotalByMonthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TotalByMonthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTotalByMonth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/report/total-by-month"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "year", r.year, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetTotalByRangeRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	status     *string
	isAd       *string
	startDate  *string
	toDate     *string
}

// [пустой] - все \&quot;delivered\&quot; - только частично и полностью доставленное \&quot;rejected\&quot; - только не доставленное
func (r DefaultApiGetTotalByRangeRequest) Status(status string) DefaultApiGetTotalByRangeRequest {
	r.status = &status
	return r
}

// [пустой] - все 1 - только рекламное 0 - только сервисное
func (r DefaultApiGetTotalByRangeRequest) IsAd(isAd string) DefaultApiGetTotalByRangeRequest {
	r.isAd = &isAd
	return r
}

// С &#x60;%Y-%m-%d %H:%M&#x60;
func (r DefaultApiGetTotalByRangeRequest) StartDate(startDate string) DefaultApiGetTotalByRangeRequest {
	r.startDate = &startDate
	return r
}

// По &#x60;%Y-%m-%d %H:%M&#x60;
func (r DefaultApiGetTotalByRangeRequest) ToDate(toDate string) DefaultApiGetTotalByRangeRequest {
	r.toDate = &toDate
	return r
}

func (r DefaultApiGetTotalByRangeRequest) Execute() (*UserTotalsResponse, *http.Response, error) {
	return r.ApiService.GetTotalByRangeExecute(r)
}

/*
GetTotalByRange Расходы по датам

Расходы по датам

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetTotalByRangeRequest
*/
func (a *DefaultApiService) GetTotalByRange(ctx context.Context) DefaultApiGetTotalByRangeRequest {
	return DefaultApiGetTotalByRangeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserTotalsResponse
func (a *DefaultApiService) GetTotalByRangeExecute(r DefaultApiGetTotalByRangeRequest) (*UserTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTotalByRange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/report/total-by-range"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAd != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_ad", r.isAd, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_date", r.startDate, "", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "to_date", r.toDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetTotalBySmscRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	month      *string
	year       *string
}

// Месяц
func (r DefaultApiGetTotalBySmscRequest) Month(month string) DefaultApiGetTotalBySmscRequest {
	r.month = &month
	return r
}

// Год
func (r DefaultApiGetTotalBySmscRequest) Year(year string) DefaultApiGetTotalBySmscRequest {
	r.year = &year
	return r
}

func (r DefaultApiGetTotalBySmscRequest) Execute() (*TotalBySmscResponse, *http.Response, error) {
	return r.ApiService.GetTotalBySmscExecute(r)
}

/*
GetTotalBySmsc Итого по компаниям

**smsc_id** - ID компании

| smsc_id | Компания |
| --- | --- |
| 1 | Mobiuz |
| 2 | Beeline |
| 3 | Ucell |
| 4 | Humans |
| 5 | Uzmobile GSM |
| 6 | Uzmobile CDMA |
| 7 | Perfectum |
| 8 | Global |

**ad_parts** - Количество рекламных СМС
**ad_spent** - Расходы на рекламные СМС

**parts** - Количество сервисных СМС
**spent** - Расходы на сервисные СМС

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetTotalBySmscRequest
*/
func (a *DefaultApiService) GetTotalBySmsc(ctx context.Context) DefaultApiGetTotalBySmscRequest {
	return DefaultApiGetTotalBySmscRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TotalBySmscResponse
func (a *DefaultApiService) GetTotalBySmscExecute(r DefaultApiGetTotalBySmscRequest) (*TotalBySmscResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TotalBySmscResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetTotalBySmsc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/report/total-by-smsc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.month != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "month", r.month, "", "")
	}
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "year", r.year, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserInfoRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiGetUserInfoRequest) Execute() (*UserInfoResponse, *http.Response, error) {
	return r.ApiService.GetUserInfoExecute(r)
}

/*
GetUserInfo Данные ползователья

Возвращает все данные о пользователе

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserInfoRequest
*/
func (a *DefaultApiService) GetUserInfo(ctx context.Context) DefaultApiGetUserInfoRequest {
	return DefaultApiGetUserInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserInfoResponse
func (a *DefaultApiService) GetUserInfoExecute(r DefaultApiGetUserInfoRequest) (*UserInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/auth/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserLimitRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiGetUserLimitRequest) Execute() (*UserLimitResponse, *http.Response, error) {
	return r.ApiService.GetUserLimitExecute(r)
}

/*
GetUserLimit Получить баланс

Получить баланс

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserLimitRequest
*/
func (a *DefaultApiService) GetUserLimit(ctx context.Context) DefaultApiGetUserLimitRequest {
	return DefaultApiGetUserLimitRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserLimitResponse
func (a *DefaultApiService) GetUserLimitExecute(r DefaultApiGetUserLimitRequest) (*UserLimitResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserLimitResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserLimit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/get-limit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserMessagesRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	status     *string
	count      *string
	isAd       *string
	pageSize   *string
	startDate  *string
	toDate     *string
}

// [пустой] - все \&quot;delivered\&quot; - только частично и полностью доставленное \&quot;rejected\&quot; - только не доставленное
func (r DefaultApiGetUserMessagesRequest) Status(status string) DefaultApiGetUserMessagesRequest {
	r.status = &status
	return r
}

// 1 - Если необходимо получить итог по статусу
func (r DefaultApiGetUserMessagesRequest) Count(count string) DefaultApiGetUserMessagesRequest {
	r.count = &count
	return r
}

// [пустой] - все 1 - только рекламное 0 - только сервисное
func (r DefaultApiGetUserMessagesRequest) IsAd(isAd string) DefaultApiGetUserMessagesRequest {
	r.isAd = &isAd
	return r
}

// Количество SMS сообщений (с 20 до 200)
func (r DefaultApiGetUserMessagesRequest) PageSize(pageSize string) DefaultApiGetUserMessagesRequest {
	r.pageSize = &pageSize
	return r
}

// С &#x60;%Y-%m-%d %H:%M&#x60;
func (r DefaultApiGetUserMessagesRequest) StartDate(startDate string) DefaultApiGetUserMessagesRequest {
	r.startDate = &startDate
	return r
}

// По &#x60;%Y-%m-%d %H:%M&#x60;
func (r DefaultApiGetUserMessagesRequest) ToDate(toDate string) DefaultApiGetUserMessagesRequest {
	r.toDate = &toDate
	return r
}

func (r DefaultApiGetUserMessagesRequest) Execute() (*UserMessagesResponse, *http.Response, error) {
	return r.ApiService.GetUserMessagesExecute(r)
}

/*
GetUserMessages Детализация

**id** - Идентификатор пользователя
**country_id** - Идентификатор страны, куда отправлено SMS (null - Узбекистан)
**smsc_id** - Идентификатор компании, отправившей SMS
**dispatch_id** - Идентификатор рассылки
**user_sms_id** - Идентификатор SMS, который отправил пользователь
**request_id** - Идентификатор запроса, по которому было отправлено SMS
**price** - Цена за каждую часть SMS (полная стоимость SMS вычисляется как price \* parts_count)
**is_ad** - Рекламное SMS
**nick** - Никнейм
**to** - Номер телефона, на который отправлено SMS
**message** - Текст SMS
**encoding** - Способ кодирования SMS (0 - GSM 0338, 1 - ASCII, 8 - UCS2)
**parts_count** - Количество частей SMS (зависит от типа кодировки)
**parts**: - Информация о частях SMS

- **\[MSG_ID\]**: Идентификатор SMS, полученный от компании

  - **part_index** - Порядковый номер каждой части SMS

  - **accepted** - true или false

  - **accept_time** - Время отправки SMS

  - **accept_status** - Состояние SMS, полученной от компании (значение SubmitSMResp.CommandStatus)

  - **dlr_state** - Статус доставленного SMS

  - **dlr_time** - Время доставки SMS

**status** - Общее состояние SMS
**smsc_data** - Изменение состояния для каждой части
**sent_at** - Время, когда система Eskiz.uz приняла SMS
**submit_sm_resp_at** - Время отправки последней части SMS компании
**delivery_sm_at** - Время доставки последней части SMS пользователю
**created_at** - Дата создания записи
**updated_at** - Дата последнего изменения записи

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserMessagesRequest
*/
func (a *DefaultApiService) GetUserMessages(ctx context.Context) DefaultApiGetUserMessagesRequest {
	return DefaultApiGetUserMessagesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserMessagesResponse
func (a *DefaultApiService) GetUserMessagesExecute(r DefaultApiGetUserMessagesRequest) (*UserMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/get-user-messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "count", r.count, "", "")
	}
	if r.isAd != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_ad", r.isAd, "", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "page_size", r.pageSize, "", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "start_date", r.startDate, "", "")
	}
	if r.toDate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "to_date", r.toDate, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserMessagesByDispatchRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	status     *string
	count      *string
	dispatchId *string
	isAd       *string
}

// [пустой] - все \&quot;delivered\&quot; - только частично и полностью доставленное \&quot;rejected\&quot; - только не доставленное
func (r DefaultApiGetUserMessagesByDispatchRequest) Status(status string) DefaultApiGetUserMessagesByDispatchRequest {
	r.status = &status
	return r
}

// 1 - Если необходимо получить итог по статусу
func (r DefaultApiGetUserMessagesByDispatchRequest) Count(count string) DefaultApiGetUserMessagesByDispatchRequest {
	r.count = &count
	return r
}

// ID рассылки
func (r DefaultApiGetUserMessagesByDispatchRequest) DispatchId(dispatchId string) DefaultApiGetUserMessagesByDispatchRequest {
	r.dispatchId = &dispatchId
	return r
}

// [пустой] - все 1 - только рекламное 0 - только сервисное
func (r DefaultApiGetUserMessagesByDispatchRequest) IsAd(isAd string) DefaultApiGetUserMessagesByDispatchRequest {
	r.isAd = &isAd
	return r
}

func (r DefaultApiGetUserMessagesByDispatchRequest) Execute() (*UserMessagesResponse, *http.Response, error) {
	return r.ApiService.GetUserMessagesByDispatchExecute(r)
}

/*
GetUserMessagesByDispatch Получить СМС по рассылке

Получить все отправленные СМС по ID рассылке

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserMessagesByDispatchRequest
*/
func (a *DefaultApiService) GetUserMessagesByDispatch(ctx context.Context) DefaultApiGetUserMessagesByDispatchRequest {
	return DefaultApiGetUserMessagesByDispatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserMessagesResponse
func (a *DefaultApiService) GetUserMessagesByDispatchExecute(r DefaultApiGetUserMessagesByDispatchRequest) (*UserMessagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserMessagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserMessagesByDispatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/get-user-messages-by-dispatch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "count", r.count, "", "")
	}
	if r.dispatchId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "dispatch_id", r.dispatchId, "", "")
	}
	if r.isAd != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_ad", r.isAd, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserTemplatesRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiGetUserTemplatesRequest) Execute() (*TemplatesListResponse, *http.Response, error) {
	return r.ApiService.GetUserTemplatesExecute(r)
}

/*
GetUserTemplates Получить список шаблонов

# Получить все шаблоны

status:
moderation => На модерации
inproccess => В процессе
service => Сервисный
reklama => Рекламный
rejected => Отказано

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserTemplatesRequest
*/
func (a *DefaultApiService) GetUserTemplates(ctx context.Context) DefaultApiGetUserTemplatesRequest {
	return DefaultApiGetUserTemplatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TemplatesListResponse
func (a *DefaultApiService) GetUserTemplatesExecute(r DefaultApiGetUserTemplatesRequest) (*TemplatesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TemplatesListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiGetUserTotalsRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	isGlobal   *string
	month      *string
	year       *string
}

func (r DefaultApiGetUserTotalsRequest) IsGlobal(isGlobal string) DefaultApiGetUserTotalsRequest {
	r.isGlobal = &isGlobal
	return r
}

func (r DefaultApiGetUserTotalsRequest) Month(month string) DefaultApiGetUserTotalsRequest {
	r.month = &month
	return r
}

func (r DefaultApiGetUserTotalsRequest) Year(year string) DefaultApiGetUserTotalsRequest {
	r.year = &year
	return r
}

func (r DefaultApiGetUserTotalsRequest) Execute() (*UserTotalsResponse, *http.Response, error) {
	return r.ApiService.GetUserTotalsExecute(r)
}

/*
GetUserTotals Итог отправленных СМС

Итого отправленных СМС

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiGetUserTotalsRequest
*/
func (a *DefaultApiService) GetUserTotals(ctx context.Context) DefaultApiGetUserTotalsRequest {
	return DefaultApiGetUserTotalsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UserTotalsResponse
func (a *DefaultApiService) GetUserTotalsExecute(r DefaultApiGetUserTotalsRequest) (*UserTotalsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UserTotalsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetUserTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/totals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isGlobal != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_global", r.isGlobal, "", "")
	}
	if r.month != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "month", r.month, "", "")
	}
	if r.year != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "year", r.year, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiLoginRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	email      *string
	password   *string
}

func (r DefaultApiLoginRequest) Email(email string) DefaultApiLoginRequest {
	r.email = &email
	return r
}

func (r DefaultApiLoginRequest) Password(password string) DefaultApiLoginRequest {
	r.password = &password
	return r
}

func (r DefaultApiLoginRequest) Execute() (*LoginResponse, *http.Response, error) {
	return r.ApiService.LoginExecute(r)
}

/*
Login Получить токен

Для авторизации используйте этот API, возвращает токен

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiLoginRequest
*/
func (a *DefaultApiService) Login(ctx context.Context) DefaultApiLoginRequest {
	return DefaultApiLoginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LoginResponse
func (a *DefaultApiService) LoginExecute(r DefaultApiLoginRequest) (*LoginResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.Login")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/auth/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "email", r.email, "", "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "password", r.password, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiNormalizeSmsRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	message    *string
}

// Сообщение
func (r DefaultApiNormalizeSmsRequest) Message(message string) DefaultApiNormalizeSmsRequest {
	r.message = &message
	return r
}

func (r DefaultApiNormalizeSmsRequest) Execute() (*NormalizeSmsResponse, *http.Response, error) {
	return r.ApiService.NormalizeSmsExecute(r)
}

/*
NormalizeSms Нормализации SMS

Этот API предоставляет информацию о наличии специальных символов в SMS-сообщении, а также о том, какими символами можно заменить специальные символы.

Используя этот API, вы можете отправлять свои SMS дешевле.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiNormalizeSmsRequest
*/
func (a *DefaultApiService) NormalizeSms(ctx context.Context) DefaultApiNormalizeSmsRequest {
	return DefaultApiNormalizeSmsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NormalizeSmsResponse
func (a *DefaultApiService) NormalizeSmsExecute(r DefaultApiNormalizeSmsRequest) (*NormalizeSmsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NormalizeSmsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.NormalizeSms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/normalizer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiRefreshTokenRequest struct {
	ctx        context.Context
	ApiService DefaultApi
}

func (r DefaultApiRefreshTokenRequest) Execute() (*RefreshTokenResponse, *http.Response, error) {
	return r.ApiService.RefreshTokenExecute(r)
}

/*
RefreshToken Обновить токен

Обновляет текущий токен

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiRefreshTokenRequest
*/
func (a *DefaultApiService) RefreshToken(ctx context.Context) DefaultApiRefreshTokenRequest {
	return DefaultApiRefreshTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return RefreshTokenResponse
func (a *DefaultApiService) RefreshTokenExecute(r DefaultApiRefreshTokenRequest) (*RefreshTokenResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RefreshTokenResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RefreshToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/auth/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiSendSmsRequest struct {
	ctx         context.Context
	ApiService  DefaultApi
	callbackUrl *string
	from        *string
	message     *string
	mobilePhone *string
}

// Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате: &#x60;{\\\&quot;request_id\\\&quot;: \\\&quot;UUID\\\&quot;, \\\&quot;message_id\\\&quot;: \\\&quot;4385062\\\&quot;, \\\&quot;user_sms_id\\\&quot;: \\\&quot;vash_ID_zdes\\\&quot;, \\\&quot;country\\\&quot;: \\\&quot;UZ\\\&quot;, \\\&quot;phone_number\\\&quot;: \\\&quot;998991234567\\\&quot;, \\\&quot;sms_count\\\&quot;: \\\&quot;1\\\&quot;, \\\&quot;status\\\&quot; : \\\&quot;DELIVRD\\\&quot;, \\\&quot;status_date\\\&quot;: \\\&quot;2021-04-02 00:39:36\\\&quot;}&#x60;.   request_id — это значение, возвращаемое в поле \\\&quot;id\\\&quot; в результате выполнения API запросов send, send-batch и send-global.
func (r DefaultApiSendSmsRequest) CallbackUrl(callbackUrl string) DefaultApiSendSmsRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// Для того, чтобы использовать никнейм, вам нужно поменять 4546 на свои.
func (r DefaultApiSendSmsRequest) From(from string) DefaultApiSendSmsRequest {
	r.from = &from
	return r
}

// Сообщение
func (r DefaultApiSendSmsRequest) Message(message string) DefaultApiSendSmsRequest {
	r.message = &message
	return r
}

// Номер телефона
func (r DefaultApiSendSmsRequest) MobilePhone(mobilePhone string) DefaultApiSendSmsRequest {
	r.mobilePhone = &mobilePhone
	return r
}

func (r DefaultApiSendSmsRequest) Execute() (*SendSmsResponse, *http.Response, error) {
	return r.ApiService.SendSmsExecute(r)
}

/*
SendSms Отправить СМС

Для того, чтобы использовать никнейм, вам нужно поменять поле «FROM» на свои.

**callback_url** - Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате:

**{"request_id": "UUID", "message_id": "4385062", "user_sms_id": "vash_ID_zdes", "country": "UZ", "phone_number": "998991234567", "sms_count": "1", "status" : "DELIVRD", "status_date": "2021-04-02 00:39:36"}**

`request_id` — это значение, возвращаемое в поле "id" в результате выполнения API запросов send, send-batch и send-global.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiSendSmsRequest
*/
func (a *DefaultApiService) SendSms(ctx context.Context) DefaultApiSendSmsRequest {
	return DefaultApiSendSmsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SendSmsResponse
func (a *DefaultApiService) SendSmsExecute(r DefaultApiSendSmsRequest) (*SendSmsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SendSmsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendSms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/send"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.callbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callback_url", r.callbackUrl, "", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "from", r.from, "", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "", "")
	}
	if r.mobilePhone != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mobile_phone", r.mobilePhone, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiSendSmsBatchRequest struct {
	ctx                 context.Context
	ApiService          DefaultApi
	sendSmsBatchRequest *SendSmsBatchRequest
}

func (r DefaultApiSendSmsBatchRequest) SendSmsBatchRequest(sendSmsBatchRequest SendSmsBatchRequest) DefaultApiSendSmsBatchRequest {
	r.sendSmsBatchRequest = &sendSmsBatchRequest
	return r
}

func (r DefaultApiSendSmsBatchRequest) Execute() (*SendSmsBatchResponse, *http.Response, error) {
	return r.ApiService.SendSmsBatchExecute(r)
}

/*
SendSmsBatch Отправить СМС рассылка

Отправить СМС рассылка

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiSendSmsBatchRequest
*/
func (a *DefaultApiService) SendSmsBatch(ctx context.Context) DefaultApiSendSmsBatchRequest {
	return DefaultApiSendSmsBatchRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SendSmsBatchResponse
func (a *DefaultApiService) SendSmsBatchExecute(r DefaultApiSendSmsBatchRequest) (*SendSmsBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SendSmsBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendSmsBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/send-batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendSmsBatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiSendSmsGlobalRequest struct {
	ctx         context.Context
	ApiService  DefaultApi
	callbackUrl *string
	countryCode *string
	message     *string
	mobilePhone *string
	unicode     *string
}

// Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате: &#x60;{\\\&quot;request_id\\\&quot;: \\\&quot;UUID\\\&quot;, \\\&quot;message_id\\\&quot;: \\\&quot;4385062\\\&quot;, \\\&quot;user_sms_id\\\&quot;: \\\&quot;vash_ID_zdes\\\&quot;, \\\&quot;country\\\&quot;: \\\&quot;UZ\\\&quot;, \\\&quot;phone_number\\\&quot;: \\\&quot;998991234567\\\&quot;, \\\&quot;sms_count\\\&quot;: \\\&quot;1\\\&quot;, \\\&quot;status\\\&quot; : \\\&quot;DELIVRD\\\&quot;, \\\&quot;status_date\\\&quot;: \\\&quot;2021-04-02 00:39:36\\\&quot;}&#x60;  request_id — это значение, возвращаемое в поле \\\&quot;id\\\&quot; в результате выполнения API запросов send, send-batch и send-global.
func (r DefaultApiSendSmsGlobalRequest) CallbackUrl(callbackUrl string) DefaultApiSendSmsGlobalRequest {
	r.callbackUrl = &callbackUrl
	return r
}

// Страна
func (r DefaultApiSendSmsGlobalRequest) CountryCode(countryCode string) DefaultApiSendSmsGlobalRequest {
	r.countryCode = &countryCode
	return r
}

// Сообщение
func (r DefaultApiSendSmsGlobalRequest) Message(message string) DefaultApiSendSmsGlobalRequest {
	r.message = &message
	return r
}

// Номер телефона
func (r DefaultApiSendSmsGlobalRequest) MobilePhone(mobilePhone string) DefaultApiSendSmsGlobalRequest {
	r.mobilePhone = &mobilePhone
	return r
}

// 1 - если хотите отправить на кирилице
func (r DefaultApiSendSmsGlobalRequest) Unicode(unicode string) DefaultApiSendSmsGlobalRequest {
	r.unicode = &unicode
	return r
}

func (r DefaultApiSendSmsGlobalRequest) Execute() (*SendSmsResponse, *http.Response, error) {
	return r.ApiService.SendSmsGlobalExecute(r)
}

/*
SendSmsGlobal Отправить Международный СМС

Используя этот API вы можете отправить СМС зарубежных стран мира.

**callback_url** - Это необязательное поле, которое используется для автоматического получения смс-статуса с сервера. Укажите URL-адрес обратного вызова, по которому вы будете получать данные POST в следующем формате:

**{"message_id": "4385062", "country": "US", "phone_number": "1234567891011", "sms_count": "1", "status" : "DELIVRD", "status_date": "2021-04-02 00:39:36"}**

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiSendSmsGlobalRequest
*/
func (a *DefaultApiService) SendSmsGlobal(ctx context.Context) DefaultApiSendSmsGlobalRequest {
	return DefaultApiSendSmsGlobalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SendSmsResponse
func (a *DefaultApiService) SendSmsGlobalExecute(r DefaultApiSendSmsGlobalRequest) (*SendSmsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SendSmsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendSmsGlobal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/message/sms/send-global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.callbackUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "callback_url", r.callbackUrl, "", "")
	}
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "country_code", r.countryCode, "", "")
	}
	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "message", r.message, "", "")
	}
	if r.mobilePhone != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "mobile_phone", r.mobilePhone, "", "")
	}
	if r.unicode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "unicode", r.unicode, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type DefaultApiSendTemplateRequest struct {
	ctx        context.Context
	ApiService DefaultApi
	template   *string
}

// шаблон или текс сообщение
func (r DefaultApiSendTemplateRequest) Template(template string) DefaultApiSendTemplateRequest {
	r.template = &template
	return r
}

func (r DefaultApiSendTemplateRequest) Execute() (*SendTemplateResponse, *http.Response, error) {
	return r.ApiService.SendTemplateExecute(r)
}

/*
SendTemplate Отправить шаблон

Получить шаблон по ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return DefaultApiSendTemplateRequest
*/
func (a *DefaultApiService) SendTemplate(ctx context.Context) DefaultApiSendTemplateRequest {
	return DefaultApiSendTemplateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SendTemplateResponse
func (a *DefaultApiService) SendTemplateExecute(r DefaultApiSendTemplateRequest) (*SendTemplateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SendTemplateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.SendTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user/template"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.template != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "template", r.template, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
